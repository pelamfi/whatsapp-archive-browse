"""
Output verification utilities for WhatsApp archive browser tests.

This module provides utilities for comparing test outputs against reference files in a way
that's suitable for tests that generate complex directory structures with multiple files.

The main workflow is:
1. Test generates output files
2. Output is compared against reference files stored in tests/resources/reference_output/<test_case>
3. If a reference file doesn't exist, it's created and a warning is shown
4. If all reference files exist, they're compared with the test output

Key features:
- Creates all missing reference files in one run instead of failing on the first missing file
- Uses warnings instead of test failures when creating reference files
- Reference files are tracked in git, so they can be reviewed during code review
- Directory structure is verified to match exactly between output and reference
- Presence of support files (media dirs) is verified without content comparison

Example usage:
    def test_something(test_env):
        # Generate output files
        output_dir = test_env.create_output_dir()
        generate_output(output_dir)

        # Compare with reference files in tests/resources/reference_output/my_test
        verify_output_directory(output_dir, 'my_test')

To update reference files:
1. Delete the reference files you want to update
2. Run the test - new reference files will be created
3. Review the changes
4. Commit the updated reference files

Note: This approach assumes that reference files should only change when functionality
intentionally changes, and that such changes should be reviewed as part of code review.
"""

import os
import shutil
import warnings


def get_reference_dir(name: str) -> str:
    """Get the path to a reference directory."""
    return os.path.join(os.path.dirname(os.path.dirname(__file__)), "resources", "reference_output", name)


def compare_or_update_reference(output_path: str, reference_path: str) -> bool:
    """
    Compare output file with reference, or create/update reference if it doesn't exist.

    Args:
        output_path: Path to the file generated by the test
        reference_path: Path where the reference file should be

    Returns:
        bool: True if files were compared, False if reference was created

    The function will:
    - Create reference file directory if it doesn't exist
    - If reference file doesn't exist:
        - Create it by copying the output file
        - Issue a warning
        - Return False
    - If reference exists:
        - Compare contents (ignoring trailing whitespace)
        - Raise AssertionError if different
        - Return True
    """
    # Create reference directory if it doesn't exist
    os.makedirs(os.path.dirname(reference_path), exist_ok=True)

    if not os.path.exists(reference_path):
        # Reference doesn't exist - create it
        shutil.copy2(output_path, reference_path)
        warnings.warn(
            f"\nReference file created: {reference_path}\n" f"Please verify its contents before committing.",
            RuntimeWarning,
        )
        return False

    # Check if this is a text file that should be compared with text diff
    is_text_file = any(output_path.endswith(ext) for ext in [".txt", ".html", ".json"])

    if is_text_file:
        # Compare text files with diff
        with (
            open(output_path, "r", encoding="utf-8") as f1,
            open(reference_path, "r", encoding="utf-8") as f2,
        ):
            output_content = f1.read().strip()
            reference_content = f2.read().strip()
            if output_content != reference_content:
                from difflib import unified_diff

                diff = list(
                    unified_diff(
                        reference_content.splitlines(keepends=True),
                        output_content.splitlines(keepends=True),
                        fromfile=f"Reference: {os.path.relpath(reference_path)}",
                        tofile=f"Output: {os.path.relpath(output_path)}",
                    )
                )
                assert False, f"Output file differs from reference:\n{''.join(diff)}"
    else:
        # Compare binary files by checking size first, then content if sizes match
        output_size = os.path.getsize(output_path)
        reference_size = os.path.getsize(reference_path)

        if output_size != reference_size:
            assert False, (
                f"Binary file size mismatch for {os.path.relpath(output_path)}: "
                f"output size {output_size} != reference size {reference_size}"
            )

        # If sizes match, compare content
        with open(output_path, "rb") as f1, open(reference_path, "rb") as f2:
            byte_output_content: bytes = f1.read()
            byte_reference_content: bytes = f2.read()
            if byte_output_content != byte_reference_content:
                assert False, f"Binary file content differs: {os.path.relpath(output_path)}"
    return True


def verify_output_directory(output_dir: str, reference_dir: str) -> None:
    """
    Compare the output directory with a reference subdirectory.
    Structure based on README.md:
    - Top level folder:
        - index.html (compared)
        - browseability-generator-chat-data.json (compared)
        - Chat Name/
            - index.html (compared)
            - YYYY.html (compared)
            - media/ (presence checked)

    Args:
        output_dir: Directory containing test output files
        reference_dir: Directory containing reference files to compare against

    Raises:
        AssertionError: If any files differ or required files are missing

    The function will:
    - Create reference directory if needed
    - For each output file matching pattern (except excluded):
        - Compare with reference using compare_or_update_reference()
        - Track which files were processed
    - After comparing:
        - Check no extra files exist in reference dir
        - Raise error if any unmatched reference files
    """
    # Convert the reference_dir from short name to full path if needed
    reference_dir = get_reference_dir(reference_dir)
    files_compared: list[str] = []
    files_created: list[str] = []

    def safe_compare(output_path: str, reference_path: str) -> None:
        """Helper to track which files were compared vs created"""
        if compare_or_update_reference(output_path, reference_path):
            files_compared.append(os.path.relpath(reference_path, reference_dir))
        else:
            files_created.append(os.path.relpath(reference_path, reference_dir))

    # Compare top-level files
    safe_compare(
        os.path.join(output_dir, "browseability-generator-chat-data.json"),
        os.path.join(reference_dir, "browseability-generator-chat-data.json"),
    )

    safe_compare(os.path.join(output_dir, "index.html"), os.path.join(reference_dir, "index.html"))

    # Process all chat directories in output
    for chat_dir in os.listdir(output_dir):
        if not os.path.isdir(os.path.join(output_dir, chat_dir)) or chat_dir == "media":
            continue

        output_chat_dir = os.path.join(output_dir, chat_dir)
        reference_chat_dir = os.path.join(reference_dir, chat_dir)

        # Compare chat index
        safe_compare(
            os.path.join(output_chat_dir, "index.html"),
            os.path.join(reference_chat_dir, "index.html"),
        )

        # Compare all year files
        for year_file in os.listdir(output_chat_dir):
            if not year_file.endswith(".html") or year_file == "index.html":
                continue

            safe_compare(
                os.path.join(output_chat_dir, year_file),
                os.path.join(reference_chat_dir, year_file),
            )

    # Report reference file status
    if files_created:
        warnings.warn(
            f"\nReference files created in {reference_dir}:\n"
            "  " + "\n  ".join(files_created) + "\n"
            "Please verify the contents of these files before committing.",
            RuntimeWarning,
        )
    if files_compared:
        print(f"Verified {len(files_compared)} reference files in {reference_dir}")

    # Now verify final structure
    output_chat_dirs: set[str] = {
        d for d in os.listdir(output_dir) if os.path.isdir(os.path.join(output_dir, d)) and d != "media"
    }
    reference_chat_dirs: set[str] = {
        d for d in os.listdir(reference_dir) if os.path.isdir(os.path.join(reference_dir, d)) and d != "media"
    }

    # Verify output has exactly the same chat directories as reference
    assert (
        output_chat_dirs == reference_chat_dirs
    ), f"Chat directories don't match. Output has {output_chat_dirs}, reference has {reference_chat_dirs}"

    # Check media for each chat directory
    for chat_dir in output_chat_dirs:

        output_chat_dir = os.path.join(output_dir, chat_dir)
        reference_chat_dir = os.path.join(reference_dir, chat_dir)

        # Compare chat index
        compare_or_update_reference(
            os.path.join(output_chat_dir, "index.html"),
            os.path.join(reference_chat_dir, "index.html"),
        )

        # Check and compare media files
        output_media_dir = os.path.join(output_chat_dir, "media")
        reference_media_dir = os.path.join(reference_chat_dir, "media")
        assert os.path.exists(output_media_dir), f"Media directory missing from chat directory {chat_dir}"

        # Create reference media directory if it doesn't exist
        os.makedirs(reference_media_dir, exist_ok=True)

        # Compare all media files
        for media_file in os.listdir(output_media_dir):
            safe_compare(
                os.path.join(output_media_dir, media_file),
                os.path.join(reference_media_dir, media_file),
            )

        # Check for extra files in reference that don't exist in output
        reference_media_files = set(os.listdir(reference_media_dir))
        output_media_files = set(os.listdir(output_media_dir))
        assert reference_media_files == output_media_files, (
            f"Media files don't match in {chat_dir}/media. "
            f"Output has {output_media_files}, reference has {reference_media_files}"
        )

        # Compare all year files
        for year_file in os.listdir(reference_chat_dir):
            if not year_file.endswith(".html") or year_file == "index.html":
                continue

            compare_or_update_reference(
                os.path.join(output_chat_dir, year_file),
                os.path.join(reference_chat_dir, year_file),
            )
